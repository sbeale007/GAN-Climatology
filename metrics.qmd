---
title: "Metrics"
format: html
editor: visual
---

```{python}
import torch
import numpy as np
import pandas as pd
import xarray as xr
from matplotlib import pyplot as plt
import torch.nn.functional as F
```

```{r}

library(terra)
library(reticulate)
```

```{python}

pred_dir = 'C:/Users/SBEALE/Desktop/GAN Predictions/tmax/wrf/march_nonan_bc/'
pred_path = pred_dir + 'GAN_tmax_bc_march_nonan_gen250.nc'
truth_dir = "C:/Users/SBEALE/Desktop/GAN Data/tmax/wrf/march_nonan_bc/"
truth_path = truth_dir + 'prism_large.nc'

# load GAN predictions and true fields (PRISM) 
pred = xr.open_dataset(pred_path)
truth = xr.open_dataset(truth_path)
```

```{python}
# unstandardizing variables
stand = pd.read_csv(truth_dir + 'standardization.csv')
# stand

mean = stand['mean'][0]
std = stand['std'][0]
truth['tmax'] = (truth.tmax*std)+mean

# cropping to testing area 
pred_test = pred.sel(longitude=slice(-128, -120), latitude=slice(60, 56.02))
truth_test = truth.sel(longitude=slice(-128, -120), latitude=slice(60, 56.02))

# make torch tensors of fields to compute MAE and RAPSD
x = np.array(pred_test.tmax).shape[0]
y = np.array(pred_test.tmax).shape[1]
pred_tens = torch.from_numpy(np.array(pred_test.tmax)).reshape(1,1,x,y)
truth_tens = torch.from_numpy(np.array(truth_test.tmax)).reshape(1,1,x,y)

# calculate MAE between truth and prediction 
MAE = F.l1_loss(truth_tens, pred_tens)
# print(MAE)

# plotting truth, prediction, and difference (choose to save or not) 
fig, ax = plt.subplots(1, 3, layout='constrained', figsize=(10, 5), sharex=True, sharey=True)

minmin = np.min(truth_test.tmax)
maxmax = np.max(truth_test.tmax)
# precip (30), temp max (3)
dmin = -3
dmax = 3

pc1 = ax[0].pcolormesh(truth_test.longitude, truth_test.latitude, truth_test.tmax, vmin=minmin, vmax=maxmax, cmap='viridis', label=r'$m$')
ax[0].set_title(f'truth', fontsize='medium', loc='center')

pc2 = ax[1].pcolormesh(pred_test.longitude, pred_test.latitude, pred_test.tmax, vmin=minmin, vmax=maxmax, cmap='viridis', label=r'$m$')
ax[1].set_title(f'prediction', fontsize='medium', loc='center')

pc3 = ax[2].pcolormesh(pred_test.longitude, pred_test.latitude, truth_test.tmax.values-pred_test.tmax.values, vmin=dmin, vmax=dmax, cmap='RdBu', label=r'$m$')
ax[2].set_title(f'truth-prediction', fontsize='medium', loc='center')

fig.supylabel('latitude [deg N]')
fig.supxlabel('longitude [deg E]')

fig.suptitle(f"March tmax, MAE = %.2f" %MAE)

fig.colorbar(pc1, shrink=0.5, aspect=20, location='bottom', ax=ax[0:2])
fig.colorbar(pc3, shrink=0.9, aspect=20, location='bottom', ax=ax[2])
plt.savefig(pred_dir + "pred_PRISM_test_diff.png", dpi = 400)
plt.close()
```

```{python}
# code from RAPSD
# from (Nic Annau)

from typing import Generator, Tuple

import numpy as np
import scipy.stats as stats


"""This module contains functions that calculate the
radially averaged power spectral density (RASPD)
"""


def calculate_2dft(image: np.ndarray) -> np.ndarray:
    """Computes the fourier transform and returns the amplitudes"""
    fourier_image = np.fft.fftn(image)
    # fourier_image = torch.fft.fftn(image)
    fourier_amplitudes = np.abs(fourier_image)**2
    # fourier_amplitudes = torch.abs(fourier_image)**2

    return fourier_amplitudes.flatten()


def define_wavenumers(hr_dim: int) -> np.ndarray:
    """Defines the wavenumbers for the RASPD"""
    kfreq = np.fft.fftfreq(hr_dim)*hr_dim
    kfreq2D = np.meshgrid(kfreq, kfreq)
    knrm = np.sqrt(kfreq2D[0]**2 + kfreq2D[1]**2)
    return knrm.flatten()


def get_mean_bins(x, var_idx, knrm) -> Tuple:
    """Calculates the mean bins for the RASPD"""
    kbins = np.arange(0.5, x.shape[-1]//2+1, 1.)
    kvals = 0.5 * (kbins[1:] + kbins[:-1])
    wind_2d = calculate_2dft(x[var_idx, ...].cpu().detach().numpy())
    average_bins, _, _ = stats.binned_statistic(
        knrm, wind_2d, statistic="mean", bins=kbins
        )
    average_bins *= np.pi * (kbins[1:]**2 - kbins[:-1]**2)
    return average_bins, kvals


def compute_rapsd(
        hr_field: Generator,
        var_ref: dict = None,
        reduce=True
) -> np.ndarray:
    """Computes the RASPD for a given super-resolution model"""

    if var_ref is None:
        var_ref = {"tmax": 0}

    var_rapsd = {}
    [var_rapsd.setdefault(x, []) for x in var_ref]

    for x in hr_field:
        for var_name, var_idx in var_ref.items():
            knrm = define_wavenumers(x.shape[-1])
            average_bins, kvals = get_mean_bins(x, var_idx, knrm)
            var_rapsd[var_name].append(average_bins)

    var_rapsd_avg = {"k": kvals}
    for var_name in var_ref:
        if reduce:
            var_rapsd_avg[var_name] = np.mean(
                np.array(var_rapsd[var_name]),
                axis=0
            )
        else:
            var_rapsd_avg[var_name] = var_rapsd[var_name]

    return var_rapsd_avg
```

```{python}
# make tiles of testing and prediction 
x_fine= np.arange(0,truth_tens.shape[2]-128, 8)
y_fine = np.arange(0,truth_tens.shape[3]-128, 8)

truth_tiles = []
pred_tiles = []
for i in range(0, len(y_fine)):
    truth = truth_tens[:,:,:,0+y_fine[i]:128+y_fine[i]]
    pred = pred_tens[:,:,:,0+y_fine[i]:128+y_fine[i]]
    for j in range(0, len(x_fine)):
        truth_tiles.append(truth[:,:,0+x_fine[j]:128+x_fine[j]])
        pred_tiles.append(pred[:,:,0+x_fine[j]:128+x_fine[j]])
```

```{python}
# computing radialy averaged power spectrum for prediction and truth
# RAPSD requires a square input so removing edges in longitude to match latitude dimension

# doing this for testing area and training area to compare 

# previous
# pred_rapsd = compute_rapsd(pred_tens[...,242:719])
# truth_rapsd = compute_rapsd(truth_tens[...,242:719])

# loop through all tiles and calculate the RAPSD for each one, then take the average 
truth_rapsd = []
pred_rapsd = []
for i in range(len(pred_tiles)):
  truth_rapsd.append(compute_rapsd(truth_tiles[i]))
  pred_rapsd.append(compute_rapsd(pred_tiles[i]))
  
for i in range(len(pred_tiles)):
  

fig,ax = plt.subplots(1, 2, figsize=(15, 5), layout='constrained')

ax[0].plot(truth_rapsd['k'], truth_rapsd['tmax']/truth_rapsd['tmax'], label='BC PRISM')
ax[0].plot(pred_rapsd['k'], pred_rapsd['tmax']/truth_rapsd['tmax'], label='GAN', linestyle='dotted')
ax[0].set_title('Normalized Power Spectrum')

ax[1].plot(truth_rapsd['k'], truth_rapsd['tmax'], label='BC PRISM')
ax[1].plot(truth_rapsd['k'], pred_rapsd['tmax'], label='GAN', linestyle='dotted')
ax[1].set_title('Power Spectrum')

labels = ['BC PRISM', 'GAN']

ax[0].set_xscale('log')
ax[0].set_yscale('log')
ax[1].set_xscale('log')
ax[1].set_yscale('log')

fig.supylabel(r'$tmax \left[\frac{P(|k|)}{P(|k|)_{PRISM}}\right]$')
fig.supxlabel('Wavenumber $|k|$')
ax[0].grid()
ax[1].grid()

handles, labels = ax[0].get_legend_handles_labels()
# lgd = ax[0].legend(handles, labels, loc='upper center', bbox_to_anchor=(0.5,-0.1))
ax[0].legend()

plt.savefig(pred_dir + "test_RAPSD.png", dpi = 400)
plt.close()
```

```{python}
# now for some area in training region 
pred_train = pred.sel(longitude=slice(-133, -129), latitude=slice(60, 56.02))
truth_train = truth.sel(longitude=slice(-133, -129), latitude=slice(60, 56.02))

x = np.array(pred_train.tmax).shape[0]
y = np.array(truth_train.tmax).shape[1]
pred_tens_train = torch.from_numpy(np.array(pred_train.tmax)).reshape(1,1,x,y)
truth_tens_train = torch.from_numpy(np.array(truth_train.tmax)).reshape(1,1,x,y)

pred_rapsd = compute_rapsd(pred_tens_train[...,1:-2])
truth_rapsd = compute_rapsd(truth_tens_train[...,1:-2])

fig,ax = plt.subplots(1, 2, figsize=(15, 5), layout='constrained')

ax[0].plot(truth_rapsd['k'], truth_rapsd['tmax']/truth_rapsd['tmax'], label='BC PRISM')
ax[0].plot(pred_rapsd['k'], pred_rapsd['tmax']/truth_rapsd['tmax'], label='GAN', linestyle='dotted')
ax[0].set_title('Normalized Power Spectrum')

ax[1].plot(truth_rapsd['k'], truth_rapsd['tmax'], label='BC PRISM')
ax[1].plot(truth_rapsd['k'], pred_rapsd['tmax'], label='GAN', linestyle='dotted')
ax[1].set_title('Power Spectrum')

labels = ['BC PRISM', 'GAN']

ax[0].set_xscale('log')
ax[0].set_yscale('log')
ax[1].set_xscale('log')
ax[1].set_yscale('log')

fig.supylabel(r'$tmax \left[\frac{P(|k|)}{P(|k|)_{PRISM}}\right]$')
fig.supxlabel('Wavenumber $|k|$')
ax[0].grid()
ax[1].grid()

handles, labels = ax[0].get_legend_handles_labels()
# lgd = ax[0].legend(handles, labels, loc='upper center', bbox_to_anchor=(0.5,-0.1))
ax[0].legend()

plt.savefig(pred_dir + "train_RAPSD.png", dpi = 400)
plt.close()
```

```{r}
# For calculating lapse rates, terra::focalReg() is your friend with climate and elevation as the y and x. 

# In both functions, you can achieve a geographically circular focal area by correcting for the convergence of longitude lines. 

# loading rasters of prediction and PRISM 
pred <- rast(py$pred_path)
truth <- rast(py$truth_path)
dem <- rast("C:/Users/SBEALE/Desktop/Cropped_Coarsened_WRF_PRISM/no_overlap/DEM.nc")
dem_mask <- dem

slope <- terrain(dem, 'slope', unit='degrees')
slope_mask <- slope

slope_mask[slope_mask <= 0.1] <- NA

dem_mask[is.na(slope_mask)] <- NA

# pred.proj <- project(pred, dem)
# truth.proj <- project(truth, dem)

truth <- (truth*py$std)+py$mean
truth <- truth + 273.15
dem.crop <- crop(dem_mask, ext(truth))
concat.truth <- c(truth, dem.crop)

dem.crop <- crop(dem_mask, ext(pred))
pred <- pred + 273.15
concat.pred <- c(pred, dem.crop)

#function for latitude-specific correction for longitudinal length of cell
latFactor <- cos(mean(ext(dem.crop)[3:4])*(pi/180))

# function for rounding to the nearest odd integer. 
round_to_odd <- function(x) {
  if (round(x) %% 2 == 0) {
    return(floor(x/2) * 2 + 1)
  } else {
    return(round(x))
  }
}
# 
# # calculating slope of tmax (horizontal gradients? )
pred_slope <- terrain(pred, 'slope')
truth_slope <- terrain(truth, 'slope')

# focal regression for lapse rate
w <- 3
focalReg.truth <- focalReg(concat.truth, w=c(w, round_to_odd(w*latFactor)), na.rm=T)
lapse.truth <- focalReg.truth$dem
intercept.truth <- focalReg.truth$intercept

focalReg.pred <- focalReg(concat.pred, w=c(w, round_to_odd(w*latFactor)), na.rm=T)
lapse.pred <- focalReg.pred$dem
intercept.pred <- focalReg.pred$intercept

# lapse.truth[is.na(lapse.truth)] <- 0
# lapse.pred[is.na(lapse.pred)] <- 0

writeCDF(lapse.pred, paste0(py$pred_dir, "pred_lapserate.nc"), var='lapse', overwrite = T)

writeCDF(lapse.truth, paste0(py$pred_dir, "PRISM_lapserate.nc"), var='lapse', overwrite = T)

writeCDF(pred_slope, paste0(py$pred_dir, "pred_slope.nc"), var='lapse', overwrite = T)

writeCDF(truth_slope, paste0(py$pred_dir, "PRISM_slope.nc"), var='lapse', overwrite = T)
```

```{python}

pred = xr.open_dataset(pred_dir + "pred_lapserate.nc")
truth = xr.open_dataset(pred_dir + "PRISM_lapserate.nc")

pred_test = pred.sel(longitude=slice(-128, -120), latitude=slice(60, 56.02))
truth_test = truth.sel(longitude=slice(-128, -120), latitude=slice(60, 56.02))

# calculate MAE between lapse rates (slope)
pred_slope_tens = torch.from_numpy(np.array(pred_test.lapse))
truth_slope_tens = torch.from_numpy(np.array(truth_test.lapse))

MAE = F.l1_loss(pred_slope_tens, truth_slope_tens)
# print(MAE)

# plot slope 
fig, ax = plt.subplots(1, 3, layout='constrained', figsize=(10, 5), sharex=True, sharey=True)

minmin = np.min(truth_test.lapse)
maxmax = np.max(truth_test.lapse)
# tmax (0.3), tmax (0.08)
dmin = -0.04
dmax = 0.04

pc1 = ax[0].pcolormesh(truth_test.longitude, truth_test.latitude, truth_test.lapse, vmin=minmin, vmax=maxmax, cmap='viridis', label=r'$m$')
ax[0].set_title(f'truth', fontsize='medium', loc='center')

pc2 = ax[1].pcolormesh(pred_test.longitude, pred_test.latitude, pred_test.lapse, vmin=minmin, vmax=maxmax, cmap='viridis', label=r'$m$')
ax[1].set_title(f'prediction', fontsize='medium', loc='center')

pc3 = ax[2].pcolormesh(pred_test.longitude, pred_test.latitude, truth_test.lapse.values-pred_test.lapse.values, vmin=dmin, vmax=dmax, cmap='RdBu', label=r'$m$')
ax[2].set_title(f'truth-prediction', fontsize='medium', loc='center')

fig.supylabel('latitude [deg N]')
fig.supxlabel('longitude [deg E]')

fig.suptitle(f"March tmax Lapse Rate, MAE = %.2f" %MAE)

fig.colorbar(pc1, shrink=0.5, aspect=20, location='bottom', ax=ax[0:2])
fig.colorbar(pc3, shrink=0.9, aspect=20, location='bottom', ax=ax[2])
plt.savefig(pred_dir + "pred_prism_lapserate.png", dpi = 400)
plt.close()
```

```{python}
plt.close()
plt.figure()
plt.imshow(pred_tens_train[0,0,...])
plt.show()
```
